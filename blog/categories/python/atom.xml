<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | kennary island]]></title>
  <link href="http://kennyyu.me/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://kennyyu.me/"/>
  <updated>2014-06-12T16:27:37-04:00</updated>
  <id>http://kennyyu.me/</id>
  <author>
    <name><![CDATA[Kenny Yu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[197,717 Lines of Code Later...]]></title>
    <link href="http://kennyyu.me/blog/2014/06/12/197717-lines-of-code-later-dot-dot-dot/"/>
    <updated>2014-06-12T15:16:00-04:00</updated>
    <id>http://kennyyu.me/blog/2014/06/12/197717-lines-of-code-later-dot-dot-dot</id>
    <content type="html"><![CDATA[<p>After taking 18 computer science classes at Harvard (17 in CS, 1 in EE),
I was curious to see exactly how many lines of code I have written
for assignments these past four years. I was also curious what the breakdown
would be for the different programming languages I've learned over the years.</p>

<p>After looking through the archives of my computer, I calculated that I wrote
<strong>197,717</strong> lines of code (141,008 insertions, 56,709 deletions) for my
classes in the past four years! In fact, I believe this is actually
an underestimate. In this post, I'll talk about how
I calculated this number, and assumptions I made when calculating this
number.</p>

<p><img src="/images/count-course.png" alt="Lines of Code by Course" /></p>

<p><img src="/images/count-filetype.png" alt="Lines of Code by File Type" /></p>

<p><img src="/images/count-semester.png" alt="Lines of Code by Semester" /></p>

<!-- more -->


<h2>Examining my git log</h2>

<p>Fortunately, except for freshman year, I used git for all my projects
and assignments. As a result, I can compute the number of lines of code I wrote
by examining by git log history. Using git made calculating my contributions on
group projects especially easy as git keeps track of who authored each commit.
Furthermore, by examining the insertions and deletions of each commit, as opposed to
examining the line count at the HEAD of the branch, I can see a more accurate number
of lines I wrote and deleted, as opposed to the final count at the end of the
assignment/project.</p>

<p>For each git repository, I did the following:</p>

<ol>
<li><p>Determine which commits were authored by me, using the following command:
<code>git log --author=Kenny --oneline</code>.</p></li>
<li><p>For each of those commits, examine the insertion/deletion count for that
commit, broken down for each file: <code>git show COMMIT --oneline --numstat</code></p></li>
<li><p>Aggregate those stats by file name across all the commits in a repository,
then aggregate those stats by file type.</p></li>
<li><p>Do this across all the git repositories for all the courses I took.</p></li>
</ol>


<p>If you want to examine your own stats across a repository, you can check
out my <a href="https://gist.github.com/kennyyu/5e59519b3972823e20bf">python counting script</a>.
Here's a snippet of the relevent code performing the steps above.</p>

<p>``` python examining git commits
import subprocess</p>

<p>def command(s):</p>

<pre><code>"""
Runs the shell command and returns the stdout as a list
of strings.
"""
proc = subprocess.Popen(s,
                        stdout=subprocess.PIPE,
                        stderr=open(os.devnull, "w"),
                        shell=True)
# strip trailing newline characters
lines = proc.stdout.readlines()
return [l.strip() for l in lines]
</code></pre>

<p>def commits_by_author(author):</p>

<pre><code>"""
Returns the list of commit hashes by the given author
"""
lines = command("git log --author=\"%s\" --oneline" % author)
return [l.split(" ")[0] for l in lines]
</code></pre>

<p>def commit_stats(commit):</p>

<pre><code>"""
Returns a mapping of filename -&gt; (additions, deletions)
"""
lines = command("git show %s --oneline --numstat" % commit)
assert(len(lines) &gt; 0)

# the first line is just a repeat of the hash, so skip it
lines = lines[1:]

# stats are of the form:
# additions    deletions    filename
stats = {}
for l in lines:
    l = l.strip()
    if l == "":
        continue
    addition, deletion, fname = l.split()
    if addition == "-":
        addition = "0"
    if deletion == "-":
        deletion = "0"
    addition = int(addition)
    deletion = int(deletion)
    stats[fname] = (addition, deletion)
return stats
</code></pre>

<p>```</p>

<h2>Notes</h2>

<p>I followed these rules when calculating my total line count.</p>

<ul>
<li><p><strong>Ignore autogenerated, binary, or raw data files when calculating a line count.</strong>
When I performed the count on my various git repositories, I noticed that I
was not always very disciplined on what I was checking into the repository.
Often, courses would want us to submit files that were autogenerated, and so I
checked in autogenerated files, binaries, images, csvs, etc. into the repository.
Thus, I made an option in my scipt to ignore certain file extensions so
that I do not get an inflated line count. Furthermore, I took the notion of "code"
to mean anything that was not autogenerated, so I included file types like
 <code>.tex</code>, <code>.txt</code>, <code>.md</code> and <code>README</code> as code (as long as they were not autogenerated).</p></li>
<li><p><strong>Prefer underestimates over overestimates.</strong>
I did not know how to use git freshman year, and as a result, I cannot get an
accurate count for the number of lines of code for CS50, CS51, or CS179. As a result,
I only included code that I entirely wrote myself, which excludes modifying code
from distribution code from a problem set, and code I wrote as part of team projects.
For CS51, I had the original
tarball distribution for some of the assignments, so I was able to diff the distribution
code with my final assignment submittion. As a result of this exlcusion, the line count
for these three courses is much smaller than it actually is.</p></li>
<li><p><strong>Only include code written for assignments.</strong>
As a result, I did not count lines of code written for section or lines of code
I wrote when <a href="http://kennyyu.me/blog/2014/04/29/reflecting-on-3-years-of-teaching/">TFing these past 3 years</a>.</p></li>
</ul>


<h2>Classes I've Taken</h2>

<p>For reference, here's the list of the computer science classes I've taken and when
I took them (and possible links to related blog posts).</p>

<ol>
<li>CS50 - Introduction to Computer Science (Fall 2010)</li>
<li>CS51 - Abstraction and Design (Spring 2011)</li>
<li>CS179 - Design of Usable Interactive Systems (Spring 2011)</li>
<li>CS61 - Systems Programming and Machine Organization (Fall 2011)</li>
<li>CS153 - Compilers (Fall 2011)</li>
<li>CS124 - Algorithms and Data Structures (Spring 2012)</li>
<li>CS262 - Introduction to Distributed Computing (Spring 2012)</li>
<li>CS207 - Systems Development for Computational Science (Spring 2012)</li>
<li>CS121 - Introduction to Theory of Computer Science (Fall 2012)</li>
<li>CS283 - Computer Vision (Fall 2012)</li>
<li>CS181 - Artificial Intelligence (Spring 2013)</li>
<li><a href="http://kennyyu.me/blog/2014/03/20/writing-synchronization-problems-for-os161/">CS161 - Operating Systems</a> (Spring 2013)</li>
<li>CS261 - Research Topics in Operating Systems (Fall 2013)</li>
<li>CS109 - Data Science (Fall 2013)</li>
<li><a href="http://kennyyu.me/blog/2013/11/18/bootcamps/">CS91r - Supervised Reading and Research with Jim Waldo</a> (Fall 2013)</li>
<li><a href="http://kennyyu.me/blog/2014/03/19/c-error-handling/">CS165 - Data Systems</a> (Spring 2014)</li>
<li>CS91r - Supervised Reading and Research  with Margo Seltzer (Spring 2014)</li>
<li>ES50 - Introduction to Electrical Engineering (Spring 2014)</li>
</ol>


<h2>Results</h2>

<p>It's not a surprise for me that I have written more C code than any other language in college,
but it surprised me that python was a close second. However, I realized that I
now use python as my goto language for prototyping and data analysis, and I've used
python in more classes than any other class (CS283, CS181, CS109, both CS91r's, ES50, CS261)
compared to C (CS61, CS161, CS165). I was surprised the java count was so high,
as I have used java mainly in internships. I realized that this came from
CS124 (I used java for Mitzenmacher's programming assignments) and for CS262
(you gotta use java if you're in Jim Waldo's class!). Furthermore, I was shocked
that the ocaml (<code>.ml</code>) line count was so low, as I felt like I wrote much more code
when taking CS153 (Compilers). However, I haven't written ocaml code for a class since
compilers, and so this count makes sense.</p>

<p>I was a bit surprised at first on why the theoretical classes (CS124, CS121) had
such a high line count, and then I realized it was mostly due to <code>.tex</code> files.</p>

<p>CS161 is often considered the most difficult and time-consuming class at Harvard,
and so I thought that CS161 would probably have the highest line count. I was surprised
that CS181 and CS165 beat the CS161 count. I believe that because there was no
distribution code for CS165 (Data Systems), I had to write a lot more (but less interesting)
code to make all the glue for my database. For CS181, the course and assignments
were so disorganized the year I took it, and as a result, there were frequent large commits
that were mostly overhaul and rewriting everything.</p>

<p>When examining the line count by semester, my spring semesters have a much
higher line count than my fall semester, and my Spring 2013 semester has the
highest count (not a surprise! I was taking CS161 and CS181 at that time).</p>

<h2>Conclusion</h2>

<p>In the end, I calculated that I made 197,717 changes
(141,008 insertions, 56,709 deletions) over the past four years. This number is
probably an underestimate, but I assume it's around the ballpark of the true number
of lines of code I've written in college. This makes me appreciate just how much
one can learn and do in four years!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tiniBot: A Voice-Activated Drink Mixer]]></title>
    <link href="http://kennyyu.me/blog/2014/06/04/tinibot-a-voice-activated-drink-mixer/"/>
    <updated>2014-06-04T19:34:00-04:00</updated>
    <id>http://kennyyu.me/blog/2014/06/04/tinibot-a-voice-activated-drink-mixer</id>
    <content type="html"><![CDATA[<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/xetTOXwaTmc "></iframe></div></p>

<p>This past semester, I took ES50, Harvard's introductory course in electrical
engineering. For our final project, my group decided to make a voice-activated
drink mixer! I was in charge of the coding component of the project.</p>

<p><img src="/images/tinibot-code.jpg" alt="Omnibox GDrive Search" /></p>

<p>The code is available on <a href="https://github.com/kennyyu/tinibot">github</a>.
To do the speech recognition, I
used the Chrome Speech API. Once I have the transcribed text, I send
the text to a local server, which figures out the drink that was ordered,
and then sends the appropriate times to open each of the bottles.
The server sends these times to the attached Arduino, which then
sends current to the appropriate solenoid valves for the designated times.
When activated, the solenoid valves allow liquid to flow through.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Through Bootcamps]]></title>
    <link href="http://kennyyu.me/blog/2013/11/18/bootcamps/"/>
    <updated>2013-11-18T11:25:00-05:00</updated>
    <id>http://kennyyu.me/blog/2013/11/18/bootcamps</id>
    <content type="html"><![CDATA[<p>This semester, I've been writing and leading <a href="https://github.com/hcs/bootcamp-main/">bootcamps</a> as the
<a href="http://www.hcs.harvard.edu/">Harvard Computer Society</a> Bootcamp Manager. In the past, HCS has
had bootcamps on various topics including python, javascript, and git. Bootcamps are typically
targetted for students just starting computer science (fresh{wo}men, sophomores).</p>

<p>My goal this smester was to restart the bootcamps and to revamp the curriculum. In this post, I'll talk about:</p>

<ol>
<li>The <strong>bootcamp curriculum</strong> I designed</li>
<li>The typical <strong>workflow</strong> for a bootcamp</li>
<li>The <strong>design decisions</strong> that went into writing these bootcamps</li>
<li>Some high level <strong>results</strong> (pull request numbers and summary of testimonials)</li>
<li><strong>Unedited testimonials</strong> from students in the bootcamps</li>
</ol>


<!-- more -->


<h2>Bootcamp Curriculum</h2>

<ol>
<li><p><a href="https://github.com/hcs/bootcamp-setup/wiki">Bootcamp Setup</a> and <a href="http://goo.gl/jk45W1">slides</a>.
From my experience leading bootcamps
last semester, I realized it is really hard to cater to so many different programming
backgrounds and machine setups. As a result, I chose to standardize and require students
to install a UNIX system with a package manager:</p>

<ul>
<li>OSX with <a href="http://brew.sh/">homebrew</a></li>
<li><a href="https://manual.cs50.net/appliance/">CS50 Appliance</a>, since most students are either taking
or have taken <a href="https://cs50.harvard.edu/">CS50</a>, Harvard's Intro to Computer Science course.</li>
<li>Ubuntu virtual machine with VirtualBox or VMWare</li>
</ul>
</li>
<li><p><a href="https://github.com/hcs/bootcamp-unix/wiki">Intro to UNIX Part 1: Command Line</a> and <a href="http://goo.gl/5NJyWw">slides</a>.
This bootcamp presents the UNIX command line and the stdin, stdout, stderr, and pipe abstractions.
<a href="https://github.com/hcs/bootcamp-unix/wiki/Exercise:-Scavenger-hunt">Exercises</a>
include scavenger hunts through a code base using <code>find</code>, <code>grep</code>, and piping
a sequence of commands together transform and analyze files.</p></li>
<li><p><a href="https://github.com/hcs/bootcamp-unix/wiki/Shell-scripts">Intro to UNIX Part 2: Shell Scripting</a> and <a href="http://goo.gl/kRpD4y">slides</a>.
This continues the introduction to UNIX with shell scripts. Exercises include:</p>

<ul>
<li>Writing a <a href="https://github.com/hcs/bootcamp-unix/wiki/Exercise:-Shell-scripts">web scraper to scrape images from Amazon</a>
using only basic UNIX commands, and writing</li>
<li>A <a href="https://github.com/hcs/bootcamp-unix/wiki/Exercise:-Mail-Merge-Shell-Script">mail merge script</a>.</li>
</ul>
</li>
<li><p><a href="https://github.com/hcs/bootcamp-git/wiki">Git and Github</a> and <a href="http://goo.gl/siE4CQ">slides</a>.
This bootcamp introduces students to version control and using git with Github. Exercises include</p>

<ul>
<li><a href="https://github.com/hcs/bootcamp-git/wiki/Exercise-Scavenger-Hunt">Scavenger Hunt</a>
through a repository's history (e.g. which commit introduced a change, who did it, checking out an old revision)</li>
<li><a href="https://github.com/hcs/bootcamp-git/wiki/Exercise-Committing-and-Pushing">Committing and Pushing</a>. Have students
attempt to replicate a git history tree.</li>
<li><a href="https://github.com/hcs/bootcamp-git/wiki/Exercise-Resolving-Merge-Conflicts">Resolving Merge Conflicts</a>.
I made a branch that would purposely cause a merge conflict when students attempt to merge the branch
into their master branch.</li>
<li><a href="https://github.com/hcs/bootcamp-git/wiki/Exercise-Reverting-a-commit">Reverting a Commit</a>.</li>
<li><a href="https://github.com/hcs/bootcamp-git/wiki/Exercise-Making-a-Pull-Request">Making a Pull Request</a>. Students
create a pull request on github. This exercise allows students to make pull requests in the future
and to give me and the HCS board the opportunity to give them feedback on their work.</li>
</ul>
</li>
<li><p><a href="https://github.com/hcs/bootcamp-python/wiki">Intro to Python</a> and <a href="http://goo.gl/9ID3ad">slides</a>.
This bootcamp introduces students to basic feature of Python, including control flow and data structures
(lists, sets, dictionaries, tuples, strings). Exercises include:</p>

<ul>
<li><a href="https://github.com/hcs/bootcamp-python/wiki/Exercise-Hello-World">Hello World!</a>.
This also sets up a pull request to keep track of their work.</li>
<li><a href="https://github.com/hcs/bootcamp-python/wiki/Exercise-Spell-Checker">Spell Checker</a>. Inspired by CS50's
<a href="http://cdn.cs50.net/2013/fall/psets/6/pset6/pset6.html">Spell Checker</a> problem set, I wanted to
show students how much Python abstracts many things away and makes programming in Python extremely
simple and easy.</li>
<li><a href="https://github.com/hcs/bootcamp-python/wiki/Exercise-Programming">Python Exercises</a>. This is an example
of test-driven development: we give students failing unit tests, and their job is to make
all the unit tests pass.</li>
</ul>
</li>
</ol>


<h2>Workflow</h2>

<p>I designed the workflow centered around github wiki pages and pull requests. Here's the workflow for a typical bootcamp:</p>

<ol>
<li>Start reading the github wiki page for the bootcamp repository.</li>
<li>Fork the bootcamp repository and clone it to their local machines.</li>
<li>Do some of the exercises.</li>
<li>Setup a pull request using the original bootcamp respository as the base of the pull request,
and their master branch as the head of the pull request</li>
<li>Do some more exercises and push commits to their master branch, which will update their pull request.</li>
<li>Wait for feedback on the pull request.</li>
</ol>


<h2>Design Goals</h2>

<p>I designed the curriculum and workflow with multiple goals in mind:</p>

<ul>
<li><p><strong>Flipped Classroom.</strong> From my experience in classes with
<a href="http://www.eecs.harvard.edu/~margo/cs161/">flipped classrooms</a>,
students learn (at least with programing exercises) much better when they have hands-on
exercises with guidance from the instructor. With this in mind, I wrote all the bootcamps
to minimize the amount of lecturing I give and to maximize the amount of time students
would be programming and asking questions.</p></li>
<li><p><strong>Useful Software Engineering Skills.</strong> With these bootcamps, I wanted to provide
others with the exercises and support that I wish I had had as a freshmen--exercises
to teach some basic skills that would be useful not only in industry, but also
useful in an academic setting. From my experiences in internships and classes,
some of the most useful skills that have learned are</p>

<ol>
<li>using the command line effectively</li>
<li>scripting repetitive tasks (e.g. test harnesses, moving/editing files)</li>
<li>using version control</li>
<li>having a go-to language for quick prototyping and tasks</li>
</ol>
</li>
<li><p><strong>Start from Zero.</strong> Because HCS's target audience is students with very
little programming experience, I wrote the bootcamps so that anyone starting
from zero programming experience could quickly get their environment setup
and start using the command line. Naturally, there will be students that
already have programming experience, and I supplemented the basic exercises
in bootcamps with more involved exercises that students can do on their
own pace.</p></li>
<li><p><strong>Feedback System.</strong> I believe it's very important to get feedback
on your work, especially when programming for the first time. Therefore, I
designed the bootcamps to use github's pull request feature for comments
and feedback. Pull requests allow us to leave in-line comments on code,
and to provide a comment-discussion feature for general feedback. I also
encouraged students to install the <a href="https://chrome.google.com/webstore/detail/gh-diff-highlight/gjljgldconccfbldbnnpbgahpckhjcfj">GH Diff Highlight Chrome Extension</a>
to colorize pull request diffs.</p>

<p><a href="https://github.com/hcs/bootcamp-python/pulls">Here</a> are examples of the
feedback we provided on the Intro to Python bootcamp.</p></li>
<li><p><strong>Reusable.</strong> I am a senior and will be graduating soon; as a result, I
want the bootcamps to be reusable after I leave. Because of this,
I made all the bootcamps open source github repositories
so that they may be reused, updated, and forked as necessary in the future.</p></li>
</ul>


<h2>Results</h2>

<p>Overall, attendance was generally higher than I expected. The attendance for
the setup and first two UNIX bootcamps were roughly 30-40 people, which
is one of the highest attendance rates HCS has had in a while for a bootcamp.
Naturally, as the semester progresses, students get more busy with midterms and assignments,
and so attendance dropped to about 20 for git, and a dozen or so for the Python
bootcamp. After each bootcamp, I posted a survey asking for feedback. I asked
the question:</p>

<blockquote><p>What did you think of the bootcamp? (What you liked, didn't like, what was useful, wasn't useful. What would you have done differently? etc.)</p></blockquote>

<p>The feedback was generally positive. The types of feedback were generally along one or
more of these categories (see the Testimonial section at the end for real responses):</p>

<ol>
<li>Hands-on flipped classroom sessions were helpful in helping students digest the material.</li>
<li>More advanced students wanted more challenging exercises.</li>
<li>Too fast/too slow.</li>
<li>Requests for review of material from previous sessions.</li>
</ol>


<p>In terms of numbers, the <a href="https://github.com/hcs/bootcamp-git/pulls">Git and Github Bootcamp</a> had 28 forks, with 16
students successfully submitting a pull request. The <a href="https://github.com/hcs/bootcamp-git/pulls">Python Bootcamp</a> had 16 forks,
with 10 students sucessfully submitting a pull request, and 4 students finishing all the python exercises.</p>

<p>From these numbers and testimonials, it seems that the flipped classroom model worked very well,
and the various levels of exercises and walkthroughs catered to both advanced and beginner students.</p>

<h2>Testimonials</h2>

<p>Below are the unedited and anonymized testimonials from students:</p>

<h3>UNIX Part 1: Command Line</h3>

<blockquote><p>This seems well done, albeit rather basic. Maybe mentioning "do one thing well" to explain why UNIX works the way it does.</p>

<p>I thought it was good since it taught me all the basics in one sitting</p>

<p>Like it.</p>

<p>I think this was great although taught a little quickly</p>

<p>Useful, but went a little slowly; Overall was run very well, learned some useful UNIX commands.</p>

<p>Very useful! I learned a lot about some of the basic commands available to us. I wish we'd dived into the scavenger hunt sooner so we could've had more time for it and the shell script exercise.</p>

<p>I liked how many functions could be linked to each other. That was really cool. Also how there are functions that allow tons of flexibility with the -char ability.</p>

<p>Very helpful especially one-on-one. Went through the slides a bit too fast</p>

<p>Awesome! While I've done a good amount of programming before, I haven't had a chance to learn many of the covered UNIX commands... until now.</p>

<p>Thanks for an awesome class, Kenny!"</p>

<p>smaller room preferably</p>

<p>Scavenger hunt was fun. I'm glad I sat next to people who were more familiar with this material.</p>

<p>Ir was really useful.  I got a better sense of how to use the command line than ever before!  Thanks.</p>

<p>It got a little hectic at the end...</p>

<p>I thought it went a little too fast for me. But I enjoy the premises of the program. I just wish it was not so much like a class, but a collaboration so that everyone feels involved.</p>

<p>I thought it was a really good topic, but it moved to quickly for me. It also would have been nice if there were more people to answer questions, because that was really helpful. Along with piazza, it would be nice to have a small recap session to go over the topics and solidify them.</p>

<p>This was a good set of exercises.  I got distracted with unrelated things (c/p, sending the answers directly to answers.txt), so I lagged behind.</p>

<p>I liked it! I thought I knew shell scripting before, but now I feel more comfortable with channeling and piping and whatnot. :)</p>

<p>It was very informative!</p>

<p>I've learned a lot. It was very informative.</p>

<p>Great tutorial. Learned a lot about UNIX, especially piping.</p></blockquote>

<h3>UNIX Part 2: Shell Scripting</h3>

<blockquote><p>could have been a little more organized.  But people were very helpful.</p>

<p>Useful bootcamp, I didn't know how to write shell scripts...</p>

<p>I liked having the recap of last week and generally enjoyed this exercise.  I like the presence of a second exercise for those who finish early.</p>

<p>Could've used more instruction on the scraper parts - using man over and over again got annoying</p></blockquote>

<h3>Git and Github</h3>

<blockquote><p>Awesome overview of git. I knew a bit coming in, but setting up the alias for my "lg" command was great, so that I can see my requests in a more aesthetically pleasing fashion. Maybe a bit more on creating branches to make temporary changes and then merging your own branch back.</p>

<p>github is harder than i expected–it's like a whole new world of stuff! so it was largely a struggle but i think i learned a lot</p>

<p>Liked how straightforward it was. I would maybe have thrown in a challenge exercise</p>

<p>It was very fun and easy to understand. Plus, I learned a whole bunch of stuff I never knew before (and a lot of things unrelated to git, but useful as a whole, like how to use vim). :)</p>

<p>It was fantastic! I don't think I would have done anything differently.</p>

<p>Useful, already knew a decent amount about git. The pace was good, wouldn't have changed anything.</p>

<p>It is difficult but manageable</p>

<p>Exercises are nice.</p>

<p>It was great! And useful!</p>

<p>I thought the bootcamp was useful. Github is a lot more manageable and less confusing after today's bootcamp. I'm glad I came.</p>

<p>This one was really good and understandable!</p>

<p>I wasn't able to come to the bootcamp on Wednesday, but I just completed it on my own - the slides and online directions were really helpful, and I could pretty much figure most things out on my own.</p>

<p>On a side note, I also completed the mail merger exercise from last week's bootcamp, and the solution didn't follow the instructions that we were given, so that confused me a little.</p></blockquote>

<h3>Intro to Python</h3>

<blockquote><p>Pretty cool.  Exercises were nice, good practice.  I was already pretty familiar with Python, though, so not representative.</p>

<p>It was useful, especially the talk about CS classes and coursework!</p>

<p>This was a great lesson. The only problems I had were setting up git stuff, but that is mostly due to the fact that this was the first time I came up. There is not much to change other than perhaps moving a bit slower.</p>

<p>It was great! Learnt a lot about python. Especially liked the exercises that helped me get a little more used to python syntax.</p>

<p>I love to code and I love the exercises, as well as the debugger tests that let me see what I was doing wrong and which lines. Python is so applicable. To improve, I think we could get thai(Spice?) for the food next time to add variety.</p>

<p>I liked that it had fewer directed parts and relied more on us learning some of python's capabilities on our own</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pipeline for Improving Hand Tracking Accuracy]]></title>
    <link href="http://kennyyu.me/blog/2012/12/10/pipeline-for-improving-hand-tracking-accuracy/"/>
    <updated>2012-12-10T21:48:00-05:00</updated>
    <id>http://kennyyu.me/blog/2012/12/10/pipeline-for-improving-hand-tracking-accuracy</id>
    <content type="html"><![CDATA[<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/DFPg-9D46kE "></iframe></div></p>

<p>For my CS283: Computer Vision Final Project, I created an application to control Google Maps
using your hand and a webcam.</p>

<p>It uses the Chrome API to access the webcam, and frames are sent to a Tornado server that
runs the hand tracking pipeline, annotates the frame, and sends back the displacement
vector to update the view of the map. I am using OpenCV for it's Haar Cascade libraries.</p>

<p>You can <a href="https://github.com/kennyyu/cs283-project">view the code on github</a>
and setup an instance of the server locally!</p>

<p>You can also <a href="https://www.dropbox.com/s/tnyzr1qt8fmnscp/hand-tracking-pipeline.pdf">view the paper</a>
I wrote to describe the process I used in the pipeline. Below is a summary of the problem
statement and the stages in the pipeline.</p>

<h1>Problem Statement</h1>

<p>Given a poorly trained Haar Cascade Classifier (250 positive samples and 100 negative samples) to recognize hands,
this project assembles a pipeline to improve the quality of the tracking. These steps include:</p>

<ol>
<li>Face detection and removal of faces.</li>
<li>Background subtraction.</li>
<li>Use a simplified Kalman-Filter-esque technique to estimate the bounding box of the hand. This assumes that a hand moves in a smooth manner.</li>
<li>Use our hand classifier to detect the largest hand within the bounding box.</li>
<li>Compute the optical flow of points within the bounding box using Lucas-Kanade.</li>
<li>Use the optical flow and the measured position of the hand to correct our Kalman-Filter estimate.</li>
</ol>

]]></content>
  </entry>
  
</feed>
