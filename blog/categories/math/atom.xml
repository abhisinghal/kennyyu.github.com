<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: math | kennary island]]></title>
  <link href="http://kennyyu.me/blog/categories/math/atom.xml" rel="self"/>
  <link href="http://kennyyu.me/"/>
  <updated>2014-06-04T23:25:09-04:00</updated>
  <id>http://kennyyu.me/</id>
  <author>
    <name><![CDATA[Kenny Yu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Coupling and the Coupon Collector]]></title>
    <link href="http://kennyyu.me/blog/2012/06/24/coupling-and-the-coupon-collector/"/>
    <updated>2012-06-24T21:43:00-04:00</updated>
    <id>http://kennyyu.me/blog/2012/06/24/coupling-and-the-coupon-collector</id>
    <content type="html"><![CDATA[<p>In the fall semester last year, I took <a href="http://blog.bokcenter.harvard.edu/2012/01/23/stat-110-lectures-are-now-available-on-itunesu/">Stat 110</a>,
an introductory
statistics course focusing on probability. I had done probability in contest
math from high school, but this course was my first real rigorous treatment
of probability.</p>

<p>One of the most interesting problems I saw in the course involves Markov chains
and a simple and elegant solution using another interesting problem we saw
earlier in the course--<a href="http://en.wikipedia.org/wiki/Coupon_collector%27s_problem">the coupon collector's problem</a>.</p>

<h2>Random-to-Top Shuffling Problem</h2>

<p>Suppose $n$ cards are placed in order on a table. Consider the following shuffling
procedure: Pick a card at random from the deck and place it on top of the deck.
What is the expected number of times we need to repeat the process to arrive
at a "random" deck, for some suitable definition of "random"?</p>

<p>To solve this question, we'll need to answer a seemingly unrelated question first.</p>

<h2>Coupon Collector's Problem (aka. The Toy Collector's Problem)</h2>

<p>A certain brand of cereal always distributes a toy in every cereal box. The toy
chosen for each box is chosen randomly from a set of $n$ distinct toys. A toy
collector wishes to collect all $n$ distinct toys. What is the expected number
of cereal boxes must the toy collector buy so that the toy collector collects
all $n$ distinct toys?</p>

<h2>Solution to the Toy Collector's Problem</h2>

<p>The key to understanding this problem is to break the task of collecting all
$n$ distinct toys into different stages: what is the expected number of cereal
boxes that the toy collector has to buy to get the $i$-th new toy?</p>

<p>Let random variable $X_i$ be the number of boxes it takes for the toy collector
to collect the $i$-th new toy after the $i-1$-th toy has already been collected.
(Note: this does NOT mean assign numbers to toys
and then collect the $i$-th toy. Instead, this means that after $X_i$ boxes,
the toy collector would have collected $i$ distinct toys, but with only $X_i - 1$
boxes, the toy collector would have only collected $i-1$ distinct toys.)</p>

<p>Clearly $E(X_1) = 1$, because the toy collector starts off with no toys. Now
consider the $i$-th toy. After the $i-1$-th toy has been collected, then there
are $n - (i-1)$ possible toys that could be the new $i$-th toy. We can interpret
the process of waiting for the $i$-th new toy as a <a href="http://en.wikipedia.org/wiki/Geometric_distribution">geometric distribution</a>, where
each trial is buying another cereal box, "success" is getting any of the
$n - (i-1)$ uncollected toys, and
"failure" is getting any of the already collected $i - 1$ toys. From this point
of view, we see that
$$X_i - 1 \sim \textrm{Geom}(p)$$
where the probability of success $p$ is
$$p = \frac{n - (i-1)}{n}.$$</p>

<p>Here, our definition of the geometric distribution does NOT include the success.
Using the expectation of a geometric distribution, we have that the expected number
of cereal boxes the toy collector must collect to get the $i$-th new toy after
collecting $i-1$ toys is
$$E(X_i - 1) = \frac{1 - p}{p}$$
$$E(X_i) = \frac{1}{p} = \frac{n}{n - (i - 1)}.$$</p>

<p>Now let random variable $X$ to be the number of cereal boxes the toy collector
needs to buy to collect all $n$ distinct toys. Since we have separated the
process into collecting the $i$-th new toy, then
$$X = X_1 + X_2 + \cdots + X_n.$$</p>

<p>Using linearity of expectation, we can compute the expected value of $X$
by summing the individual expectations of $X_i$. Thus, we obtain the following
result:
$$E(X) = E(X_1 + X_2 + X_3 + \cdots + X_n)$$
$$E(X) = E(X_1) + E(X_2) + E(X_3) + \cdots + E(X_n)$$
$$E(X) = n\left( 1 + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n} \right).$$</p>

<p>This is the harmonic series! The harmonic series diverges to infinity and
grows approximately as $\gamma + \log n$ where $\gamma \approx 0.57722$ is
Euler's constant. Thus, we can approximate the expected number of cereal boxes with:
$$E(X) \approx n (\gamma + \log n).$$</p>

<h2>Solution to the Random-to-Top Shuffling Problem</h2>

<h3>Markov Chains and Stationary Distrubutions</h3>

<p>Coming back to the random-to-top shuffling problem, we first need to define
our notion of "random" for our deck. In order to do this, we use Markov chains.</p>

<p>For our Markov chain, let our states be all $n!$ permutations of $n$-card deck,
and two states are adjacent if and only if it is possible to reach one of the
states from the other through one step of this shuffle. For any state, we move to
one of its $n-1$ neighbors with probability $\frac{1}{n}$, or stay at the same
state with probability $\frac{1}{n}$. Since all of our $n!$ states has degree
$n$ (including loops), then by symmetry, the probability of having any
permutation is equally likely. Thus, the stationary distribution for our
random-to-top shuffling Markov process is the uniform vector
$$\vec{s} = \left(\frac{1}{n!}, ..., \frac{1}{n!}\right).$$</p>

<p>Thus, to define our notion of a "random" deck, we would like that after
implementing our shuffling algorithm, the resulting deck is sampled from our
stationary distribution: that is, our resulting deck is equally likely
to be any of the $n!$ permutations.</p>

<h3>Coupling</h3>

<p>Now that we have established that our shuffling process can be modeled with
a Markov chain that has a stationary distribution, we use the idea of "coupling"
to arrive at our solution.</p>

<p>Let deck $A$ be our original deck, and let deck $B$ be uniformly randomly sampled
from all $n!$ permutations. Since the stationary distribution for our shuffling
process is the uniform distribution, then deck $B$ is sampled from the
stationary distribution.</p>

<p>We use the fact that if we start our Markov process from a state sampled
from the stationary distribution, then the resulting state will also be
sampled from the stationary distribution. More formally:</p>

<p><strong>Lemma.</strong> <em>Let $\vec{s}$
be the stationary distribution of our Markov chain.
Let $X_0$ be our starting state, and let it
be sampled from the stationary distribution (i.e. $P(X_0 = i) = s_i$). Then
the resulting state $X_1$ after running the Markov chain for one step
will also be sampled from $\vec{s}$</em>.</p>

<p>Now consider our "coupling" strategy: every time we move a card $C$ to the top
of deck $A$, we locate card $C$ in deck $B$ and place it on top of the deck.
Note that the physical process of how we chose card $C$ in the two decks is
different: we choose a random position in deck $A$, whereas we located card
$C$ in deck $B$. Although the process of how we chose card $C$ is different,
from deck $B$'s perspective, $C$ is simply a card selected at random. Using
our lemma, we have that deck $B$ still remains sampled from the stationary
distribution after moving card $C$ to the top of deck $B$.</p>

<p>We note that after $t$ steps, all the cards that have been touched
up to time $t$ will be in the same order on top of both decks.
When all the cards of deck A and deck B are in the same order
after some time $T$ steps, we will have that deck A and deck B are both
sampled from the stationary distribution (because B always stays
stationary through our coupling strategy). Thus, after $T$ steps,
deck A will satisfy our notion of a "random" deck. We wish to compute $E(T)$.</p>

<p>How do we compute $E(T)$? We note that both decks will be the same once we have
touched all the cards. Therefore, we wish to compute the expected number
of random-to-top shuffles needed to touch all the cards.
This is an instance of the coupon collector's problem! Instead of
touching all $n$ cards, we wish the collect all $n$ coupons. Thus,
after approximately $n (\gamma + \log n)$
random-to-top shuffles, our original deck $A$
will be a "random" deck. For $n = 52$, we require $E(T) \approx 236$ shuffles
to randomize our deck.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Twist on Binary Search]]></title>
    <link href="http://kennyyu.me/blog/2012/05/18/binary-search/"/>
    <updated>2012-05-18T12:00:00-04:00</updated>
    <id>http://kennyyu.me/blog/2012/05/18/binary-search</id>
    <content type="html"><![CDATA[<p>This past semester, I took a graduate course,
<a href="http://iacs.seas.harvard.edu/courses/cs207/">CS 207</a> - Systems Development
in Computational Science. In the course, we talked about good software
engineering practices in C++ (but the lessons span beyond C++), in particular
representation invariants, abstraction functions, and writing solid code
specifications so that one could even prove things about code. The professor made
a couple of <a href="http://read.seas.harvard.edu/cs207/2012/">blog</a>
 entries for some of the lectures, explaining cool tricks with iterators and bits.</p>

<p>Early in the semester, we discussed several implementations of binary search, starting
from a simplistic version and incrementally building up to a production-ready
version. I thought the binary search discussion was an extremely eye-opening
exercise; it was my first time seeing invariants being used in proofs to prove
properties about code.</p>

<p>Below is how I've written binary search since high school:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Binary Search, Attempt #1 - search.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">Returns</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">any</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="err">@</span><span class="n">a</span> <span class="n">x</span> <span class="n">in</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">has</span> <span class="n">length</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">n</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">is</span> <span class="n">sorted</span> <span class="n">in</span> <span class="n">increasing</span> <span class="n">order</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">not</span> <span class="n">found</span>
</span><span class='line'> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="kt">int</span> <span class="n">binary_search</span><span class="p">(</span><span class="kt">int</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
</span><span class='line'>  <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Here, I am using <a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</a> style comments
for my specifications. In this version of binary search, I return the index of
<em>any</em> occurence of item <code>x</code> in array <code>a</code>, or return <code>-1</code> if there is no such
occurrence. While this implementation is acceptable for an array of ints, it
is not particularly useful for other data types.</p>

<p>Using C++ templates, we can generalize this implementation to make it
polymorphic for any type <code>T</code>, provided we provide a suitable comparison function
<code>compare</code> where <code>compare(p,q)</code> returns true if and only if <code>p</code> is less than <code>q</code>
for some ordering of values of type <code>T</code>. Thus, here is our attempt #2 at binary
search:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Binary Search, Attempt #2 - search.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">Returns</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">any</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="err">@</span><span class="n">a</span> <span class="n">x</span> <span class="n">in</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">compare</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="n">returns</span> <span class="kc">true</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">q</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">has</span> <span class="n">length</span> <span class="n">equal</span> <span class="n">to</span> <span class="err">@</span><span class="n">a</span> <span class="n">n</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">is</span> <span class="n">sorted</span> <span class="n">by</span> <span class="err">@</span><span class="n">a</span> <span class="n">compare</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">not</span> <span class="n">found</span>
</span><span class='line'> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CMP</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">binary_search2</span><span class="p">(</span><span class="n">T</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">CMP</span> <span class="n">compare</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// fix overflow issues</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">],</span><span class="n">x</span><span class="p">))</span>
</span><span class='line'>  <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">]))</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Now, in order to call binary search, we must provide a function object <code>compare</code>
that defines how we compare two elements of type <code>T</code>. Below is an example of how
we would invoke this version of binary search:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Calling Binary Search, Attempt #2 - search.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">IntComp</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">};</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">binary_search2</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">IntComp</span><span class="p">())</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
We overload <code>operator()</code> to allow <code>IntComp</code> objects to be invoked like functions,
and we pass an instance of <code>IntComp</code> to <code>binary_search2</code> whenever we perform
a binary search on an array of ints.</p>

<p>Note one other difference between the two versions of binary search: in
attempt #1, we had the line:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
whereas in attempt #2, we replaced this line with:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
For all these years, I've been writing binary search incorrectly! In the first
version, we may run into integer overflow if <code>lo + hi</code> happen to be greater
than the maximum integer value for <code>int</code>! In the second version, we fix this
subtle bug by first subtracting <code>r</code> and <code>l</code>, then halving the difference and
add the result to <code>l</code> to calculate the new middle index <code>m</code>. By subtracting
first, we are guaranteed that <code>r - l</code> will not overflow (by the implicit
precondition that <code>r</code> and <code>l</code> are valid indices into the array and <code>r &gt; l</code>),
and thus <code>m</code> will also be a valid index into the array.</p>

<p>We have generalized our binary search to work on an array containing any type.
But, we have actually done more than this. In C++, iterators overload pointer
syntax to represent collections of items. Using iterators, we can represent
an entire range of items in a collection with only two iterators--one pointing
to the beginning of the collection, and one pointing to the "position" after
the last element in the collection.
See the CS 207 blog entries <a href="http://read.seas.harvard.edu/cs207/2012/">here</a>
for more information on C++ iterators. In our example, however, we represent
the array collection with a pointer to the first position and the number
of items in the list. Because binary search requires random access into our
collection, <em>any collection represented by a random access iterator</em> will be
able to use the second version of our binary search!</p>

<p>Can we still do better? In our specification for binary search, note that we
allowed the index of <em>any</em> occurrence of our search item <code>x</code> to be returned.
This ambiguity makes it difficult to make any real use of the return value of
binary search  (except simply to check whether the item is in the collection).
Instead of returning any index, what if we returned a <em>lower bound</em> position
of the element <code>x</code> in our collection? By lower bound, we mean the first index
into the array at which we should insert <code>x</code> and still keep the elements
in sorted order.</p>

<p>For example, with the array <code>{0, 1, 2, 5, 5, 5, 7, 9}</code>, the
lower bound of <code>0</code> would be <code>0</code>, because we can insert <code>0</code> into index <code>0</code> and
still keep our array sorted. The lower bound of <code>-1</code> is also <code>0</code> by a similar
reasoning. The lower bound of <code>5</code> is <code>3</code> because <code>3</code> is the smallest index that
we can insert <code>5</code> and keep the array sorted. Similarly, the lower bound of <code>6</code>
is <code>6</code>. Note that the lower bound of <code>10</code> is <code>8</code>, which is not a valid index
into the array. This is okay because the return value only indicates the index
that one <em>could</em> insert an item and maintain the sorted property of the array.</p>

<p>To implement this, we can think of the array as a collection of boolean values
where the entries are <code>{false, false, ..., false, true, true, ... true}</code> (all
the falses occur together at the beginning of the array). The boolean values
correspond to whether our target element <code>x</code> is less than or equal to the
value in that array position. Our goal, then, is to find the first <code>true</code> in
the array, or return the last position (indicating that placing <code>x</code> at the
end of the array would maintain the sorted property of our array). Building
on the polymorphism we introduced in attempt #2, here is attempt #3 using
the lower bound idea:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Binary Search, Attempt #3 - search.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">lower</span><span class="o">-</span><span class="n">bound</span> <span class="n">position</span> <span class="n">of</span> <span class="err">@</span><span class="n">a</span> <span class="n">x</span> <span class="n">in</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">compare</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="n">returns</span> <span class="kc">true</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">q</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">has</span> <span class="n">length</span> <span class="n">equal</span> <span class="n">to</span> <span class="err">@</span><span class="n">a</span> <span class="n">n</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">is</span> <span class="n">sorted</span> <span class="n">by</span> <span class="err">@</span><span class="n">a</span> <span class="n">compare</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">post</span> <span class="k">return</span> <span class="n">R</span> <span class="n">where</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">R</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="err">@</span><span class="n">a</span> <span class="n">n</span> <span class="nl">and:</span>
</span><span class='line'> <span class="o">*</span>   <span class="n">For</span> <span class="n">all</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">n</span><span class="p">,</span>
</span><span class='line'> <span class="o">*</span>      <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">R</span> <span class="n">iff</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">x</span>
</span><span class='line'> <span class="o">*</span>      <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">R</span> <span class="n">iff</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span>
</span><span class='line'> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CMP</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">T</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">CMP</span> <span class="n">compare</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">],</span><span class="n">x</span><span class="p">))</span>
</span><span class='line'>  <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Nice, clean, and simple!</p>

<p>Note that this version uses only <em>one</em> comparison instead of two (as we did
in attempts #1 and #2)! This lower bound idea not only tells us whether our
element <code>x</code> is the array, but where we should place it to keep the list sorted!</p>

<p>This code looks simple enough to verify the correctness by eyeballing it; but
can we make this rigorous? Can we <em>prove</em> the correctness of this code? Yes!
Here is the same piece of code but commented heavily with the proof of its
own correctness.
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Binary Search Lower Bound Proof - search.cpp </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">lower</span><span class="o">-</span><span class="n">bound</span> <span class="n">position</span> <span class="n">of</span> <span class="err">@</span><span class="n">a</span> <span class="n">x</span> <span class="n">in</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">compare</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="n">returns</span> <span class="kc">true</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">q</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">has</span> <span class="n">length</span> <span class="n">equal</span> <span class="n">to</span> <span class="err">@</span><span class="n">a</span> <span class="n">n</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">pre</span> <span class="err">@</span><span class="n">a</span> <span class="n">a</span> <span class="n">is</span> <span class="n">sorted</span> <span class="n">by</span> <span class="err">@</span><span class="n">a</span> <span class="n">compare</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">post</span> <span class="k">return</span> <span class="n">R</span> <span class="n">where</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">R</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="err">@</span><span class="n">a</span> <span class="n">n</span> <span class="nl">and:</span>
</span><span class='line'> <span class="o">*</span>   <span class="n">For</span> <span class="n">all</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">n</span><span class="p">,</span>
</span><span class='line'> <span class="o">*</span>      <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">R</span> <span class="n">iff</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">x</span>
</span><span class='line'> <span class="o">*</span>      <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">R</span> <span class="n">iff</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span>
</span><span class='line'> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CMP</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">lower_bound_proof</span><span class="p">(</span><span class="n">T</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">CMP</span> <span class="n">compare</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// pre: for all i,j with 0 &amp;lt;= i &amp;lt;= j &amp;lt; n, we have a[i] &amp;lt;= a[j]</span>
</span><span class='line'>  <span class="c1">// post: let R be the return value. Then 0 &amp;lt;= R &amp;lt;= n, and</span>
</span><span class='line'>  <span class="c1">//   for all 0 &amp;lt;= i &amp;lt; n,</span>
</span><span class='line'>  <span class="c1">//     i &amp;lt; R iff a[i] &amp;lt; x    (1)</span>
</span><span class='line'>  <span class="c1">//     i &gt;= R iff a[i] &gt;= x  (2)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// PRE LOOP</span>
</span><span class='line'><span class="c1">// loop invariant: l &amp;lt;= R &amp;lt;= r (always true in the loop)</span>
</span><span class='line'><span class="c1">// decrementing function: d = r - l</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// if r - l &amp;gt;= 2, then (r - l)/2 &amp;gt;= 1,</span>
</span><span class='line'>                         <span class="c1">//                so l &amp;lt; m &amp;lt; r</span>
</span><span class='line'>                         <span class="c1">// if r - l == 1, then l = m &amp;lt; r, </span>
</span><span class='line'>                         <span class="c1">//                so l &amp;lt;= m &amp;lt; r</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">],</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// we have a[m] &amp;lt; x. Then by (1), a[m] &amp;lt; x ==&amp;gt; m &amp;lt; R</span>
</span><span class='line'>  <span class="c1">// then for all 0 &amp;lt;= i &amp;lt;= m, a[i] &amp;lt; x (b/c sorted)</span>
</span><span class='line'>  <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// so l &amp;lt; l_new == m + 1 &amp;lt;= R</span>
</span><span class='line'>             <span class="c1">// r_new == r &amp;gt;= R</span>
</span><span class='line'>             <span class="c1">// so l_new &amp;lt;= R &amp;lt;= r_new</span>
</span><span class='line'>             <span class="c1">// and r_new - l_new &amp;lt; r - l (d decrements)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// we have a[m] &amp;gt;= x. Then by (2), a[m] &amp;gt;= x ==&amp;gt; m &amp;gt;= R</span>
</span><span class='line'>  <span class="c1">// then for all m &amp;lt;= i &amp;lt; n, a[i] &amp;gt;= x (b/c sorted)</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// so r &amp;gt; r_new == m &amp;gt;= R</span>
</span><span class='line'>         <span class="c1">// l_new == l &amp;lt;= R</span>
</span><span class='line'>         <span class="c1">// so l_new &amp;lt;= R &amp;lt;= r_new</span>
</span><span class='line'>         <span class="c1">// and r_new - l_new &amp;lt; r - l (d decrements)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// POST LOOP</span>
</span><span class='line'><span class="c1">// loop invariant: l_new &amp;lt;= R &amp;lt;= r_new</span>
</span><span class='line'><span class="c1">// decrementing function: r_new - l_new &amp;lt; r - l</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">// by the decrementing function, d eventually reaches 0;</span>
</span><span class='line'>  <span class="c1">//      thus the loop terminates</span>
</span><span class='line'>  <span class="c1">// by the loop invariant, we have l &amp;lt;= R &amp;lt;= r</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
To prove the correctness, we make heavy use of the post condition:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;*</span>
</span><span class='line'> <span class="o">*</span> <span class="err">@</span><span class="n">post</span> <span class="k">return</span> <span class="n">R</span> <span class="n">where</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">R</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="err">@</span><span class="n">a</span> <span class="n">n</span> <span class="nl">and:</span>
</span><span class='line'> <span class="o">*</span>   <span class="n">For</span> <span class="n">all</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">n</span><span class="p">,</span>
</span><span class='line'> <span class="o">*</span>      <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">R</span> <span class="n">iff</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">x</span>
</span><span class='line'> <span class="o">*</span>      <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">R</span> <span class="n">iff</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span>
</span><span class='line'> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Thus, all elements at indices less than the return value <code>R</code> are less
than <code>x</code>, and all other elements are greater than or equal to <code>x</code>. We use this
both of these if and only if conditions in the two branches of the <code>if</code>
conditional to guide us on how we should update <code>l</code> or <code>r</code>.</p>

<p>In both of the branches of the conditional, we have that the new values of
<code>l</code> and <code>r</code> are maintained so that <code>l &lt;= R &lt;= r</code> and still satisfy the
post condition of the function. Thus, the statement <code>l &lt;= R &lt;= r</code> is a
<strong>loop invariant</strong> of the <code>while</code> loop: it is always true on entering and
leaving the loop. To ensure that the loop terminates, we require a
<strong>decrementing function</strong>, a function that decreases on each iteration of
the loop and is equal to zero when the loop terminates. In this case, the
obvious choice for the decrementing function would be <code>d = r - l</code>. We show
in both branches that the new values of <code>l</code> and <code>r</code> are such that
<code>r_new - l_new &lt; r - l</code>, and so <code>d</code> decreases on each iteration. When
<code>d = 0</code>, we have that <code>l = r</code>, which is indeed when the loop terminates. Thus,
our final line <code>return l;</code> is proven correct by the combination of our
post conditions, pre conditions (array is sorted), loop invariant, and
decrementing function. By analyzing the invariants in the code, the code almost
writes itself! Cool!</p>

<p>To view the code in its entirety (along with a couple of simple test harnesses
for each version of binary search), check out the source
<a href="/downloads/code/search.cpp">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Layout, LaTeX, and Tag Clouds!]]></title>
    <link href="http://kennyyu.me/blog/2012/05/17/new-layout/"/>
    <updated>2012-05-17T00:03:00-04:00</updated>
    <id>http://kennyyu.me/blog/2012/05/17/new-layout</id>
    <content type="html"><![CDATA[<p>I got a new octopress layout using Melandri's layout
<a href="http://melandri.net/2012/02/14/octopress-theme-customization/">here</a>.
I also discovered how to make cool striped backgrounds with
<a href="http://www.stripegenerator.com/">StripeGenerator</a>, use cool new fonts
from <a href="http://www.theleagueofmoveabletype.com/">The League of Movable Type</a>,
and use cool pre-made icons with
<a href="http://www.doublejdesign.co.uk/">Double-J Design</a>. Hopefully the layout
will encourage me to actually keep up with my tech blog!</p>

<p>I also installed $\LaTeX$ integration with Octopress using the handy hints from
<a href="http://luikore.github.com/2011/09/good-things-learned-from-octopress/">here</a>.
Now I can write pretty in-line equations like $e^{i\pi} + 1 = 0$ or
centered equations like
$$\int_{\Omega} \, d\omega = \int_{\partial \Omega} \, \omega.$$
Nice! Hopefully this will motivate me to write more math-related entries!</p>

<p>To keep track of tags, I installed a plugin to generate tag clouds
(see the right sidebar) using this plugin
<a href="https://github.com/tokkonopapa/octopress-tagcloud">here</a>. I also
finally discovered how to make background images that are just noises using
this background generator <a href="http://bgpatterns.com/">here</a>. I like the simplicity
of these backgrounds!</p>
]]></content>
  </entry>
  
</feed>
